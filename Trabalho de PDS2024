# Pacote para instalar
!pip install gdown

# Importar pacotes
import gdown
import pandas as pd

# Importar arquivo do Google Drive
url = f'https://drive.google.com/uc?id=1BIvaGB8cq72hsSdldi7LiNsuv0A7FkPg'
gdown.download(url, 'DogMoveData.csv', quiet=False)
# Transformar em dataframe e visualizar
df = pd.read_csv('DogMoveData.csv')
df
#Gerar duas colunas referentes às normas euclidianas do acelerômetro e do giroscópio, respectivamente
import numpy as np

df['ANorm'] = np.linalg.norm(df[['ANeck_x', 'ANeck_y', 'ANeck_z']], axis=1)
df['GNorm'] = np.linalg.norm(df[['GNeck_x', 'GNeck_y', 'GNeck_z']], axis=1)
df
# Visualização de informações acerca das normas
# Importando a biblioteca de gráficos e preparando o dataframe auxiliar

import matplotlib.pyplot as plt

df_aux = df[['t_sec','ANorm','GNorm']]
df_aux = df_aux.iloc[:200]
# Mostra um gráfico da norma euclidiana das amostras do Acelerômetro
plt.title("ANorm x t_sec")
plt.plot(df_aux["t_sec"], df_aux["ANorm"])

plt.show()
# Mostra um gráfico da norma euclidiana das amostras do Giroscópio
plt.title("GNorm x t_sec")
plt.plot(df_aux["t_sec"], df_aux["GNorm"])
plt.show()
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, ellip, freqz

def plot_filter_response(filter_type='butter', cutoff=0.5, fs=25, order=5, transition_width=0.1):
    # Definindo a frequência de corte
    if filter_type == 'butter':
        b, a = butter(order, cutoff / (0.5 * fs), btype='low', analog=False)
        label = 'Butterworth'
    elif filter_type == 'ellip':
        b, a = ellip(order, 0.1, 40, cutoff / (0.5 * fs), btype='high', analog=False)
        label = 'Elíptico'

    w, h = freqz(b, a, worN=8000)
    frequencies = (fs * 0.5 / np.pi) * w
    magnitudes = abs(h)

    # Plotando a resposta em frequência
    plt.figure(figsize=(10, 6))
    plt.plot(frequencies, magnitudes, label=f'Filtro {label}', color='blue')

    # Linhas de referência
    plt.axvline(x=cutoff, color='red', linestyle='--', label='Frequência de corte (fc)')

    # Preenchendo áreas

    if filter_type == 'butter':

      plt.fill_betweenx([0, 1], 0, cutoff, color='lightgreen', alpha=0.3, label='Banda Passante')
      transition_start = cutoff - transition_width / 2
      transition_end = cutoff + transition_width / 2
      plt.fill_betweenx([0, 1], transition_start, transition_end, color='yellow', alpha=0.3, label='Banda de Transição')
      plt.fill_betweenx([0, 1], transition_end, fs, color='red', alpha=0.2, label='Banda de Rejeição')

    elif filter_type == 'ellip':

      plt.fill_betweenx([0, 1], 0, cutoff, color='red', alpha=0.3, label='Banda de Rejeição')
      transition_start = cutoff - transition_width / 2
      transition_end = cutoff + transition_width / 2
      plt.fill_betweenx([0, 1], transition_start, transition_end, color='yellow', alpha=0.3, label='Banda de Transição')
      plt.fill_betweenx([0, 1], transition_end, fs, color='lightgreen', alpha=0.2, label='Banda Passante')

    # Configurações do gráfico
    plt.title(f'Resposta em Frequência do Filtro {label}')
    plt.xlabel('Frequência (Hz)')
    plt.ylabel('Magnitude')
    plt.grid(True)
    plt.legend()
    plt.ylim(0, 1.1)
    plt.show()

# Chamadas para plotar os filtros
plot_filter_response(filter_type='ellip', cutoff=0.5, fs=2, transition_width=0.2)
plot_filter_response(filter_type='butter', cutoff=10, fs=25, transition_width=2)
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, ellip, tf2zpk

def plot_poles_zeros(filter_type='butter', cutoff=0.5, fs=25, order=5):
    if filter_type == 'butter':
        b, a = butter(order, cutoff / (0.5 * fs), btype='low', analog=False)
    elif filter_type == 'ellip':
        b, a = ellip(order, 0.1, 40, cutoff / (0.5 * fs), btype='high', analog=False)

    # Converte os coeficientes do filtro para polos, zeros e ganho
    z, p, k = tf2zpk(b, a)

    plt.figure(figsize=(8, 8))

    # Plotando polos
    plt.scatter(np.real(p), np.imag(p), marker='x', color='red', label='Polos')

    # Plotando zeros
    plt.scatter(np.real(z), np.imag(z), marker='o', color='blue', label='Zeros')

    # Desenhando a circunferência de raio unitário
    circle = plt.Circle((0, 0), 1, color='gray', fill=False, linestyle='--', label='Circunferência de Raio Unitário')
    plt.gca().add_artist(circle)

    # Configurações do gráfico
    plt.axhline(0, color='gray', lw=0.5)
    plt.axvline(0, color='gray', lw=0.5)
    plt.xlim(-1.5, 1.5)
    plt.ylim(-1.5, 1.5)
    plt.title(f'Diagrama de Polos e Zeros - Filtro {filter_type.capitalize()}')
    plt.xlabel('Parte Real')
    plt.ylabel('Parte Imaginária')
    plt.grid()
    plt.legend()
    plt.gca().set_aspect('equal', adjustable='box')  # Para manter a proporção
    plt.show()

# Chamadas para plotar os diagramas
plot_poles_zeros(filter_type='butter', cutoff=10, fs=25, order=5)
plot_poles_zeros(filter_type='ellip', cutoff=0.5, fs=2, order=5)
from scipy.signal import butter, ellip, filtfilt
def highpass_filter(data, cutoff=0.5, fs=50, order=5):
    b, a = ellip(order, 0.1, 40, cutoff / (0.5 * fs), btype='high', analog=False)
    y = filtfilt(b, a, data)
    return y

def lowpass_filter(data, cutoff=10, fs=50, order=5):
    b, a = butter(order, cutoff / (0.5 * fs), btype='low', analog=False)
    y = filtfilt(b, a, data)
    return y


dog_ids = df['DogID'].unique()
for dog_id in dog_ids:
    subset = df[df['DogID'] == dog_id]


    filtered_a_norm = lowpass_filter(highpass_filter(subset['ANorm']))
    filtered_g_norm = lowpass_filter(highpass_filter(subset['GNorm']))


    df.loc[subset.index, 'FilteredANorm'] = filtered_a_norm
    df.loc[subset.index, 'FilteredGNorm'] = filtered_g_norm


df[['FilteredANorm', 'FilteredGNorm']].head(100)
# Visualização do efeito dos filtros

df_filt = df[['t_sec','FilteredANorm','FilteredGNorm']]
df_filt = df_filt.iloc[:200]
#df_filt
fig, axs = plt.subplots(2, 2, figsize=(11,7))
fig.suptitle('Comparação antes (em azul) e após filtros (em verde)')

axs[0, 0].plot(df_aux['t_sec'], df_aux['ANorm'], 'tab:blue')
axs[0, 0].set_title("ANorm x t_sec")

axs[0, 1].plot(df_filt['t_sec'], df_filt['FilteredANorm'], 'tab:green')
axs[0, 1].set_title("ANorm (filtrada) x t_sec")

axs[1, 0].plot(df_aux['t_sec'], df_aux['GNorm'], 'tab:blue')
axs[1, 0].set_title("GNorm x t_sec")

axs[1, 1].plot(df_filt['t_sec'], df_filt['FilteredGNorm'], 'tab:green')
axs[1, 1].set_title("GNorm (filtrada) x t_sec")
from numpy.fft import fft, fftfreq
import matplotlib.pyplot as plt

# Apenas a parte positiva da FFT (frequências e magnitudes)
freqs = fftfreq(len(df_filt['FilteredANorm']))
freqs = freqs[:len(freqs)//2]
values = df_filt['FilteredANorm']
values = values[:len(values)//2]

# Plotando o sinal original e sua transformada
plt.figure(figsize=(12, 6))

plt.subplot(2, 1, 2)
plt.stem(freqs, values)
plt.title('Anorm x freq')
plt.xlabel('Frequência (Hz)')
plt.ylabel('FilteredAnorm')

plt.tight_layout()
plt.show()
# Apenas a parte positiva da FFT (frequências e magnitudes)
freqs = fftfreq(len(df_filt['FilteredGNorm']))
freqs = freqs[:len(freqs)//2]
values = df_filt['FilteredGNorm']
values = values[:len(values)//2]

# Plotando o sinal original e sua transformada
plt.figure(figsize=(12, 6))

plt.subplot(2, 1, 2)
plt.stem(freqs, values)
plt.title('Gnorm x freq')
plt.xlabel('Frequência (Hz)')
plt.ylabel('FilteredGnorm')

plt.tight_layout()
plt.show()
def windowing(data, window_type, window_size, overlap=0.5):
    step = int(window_size * (1 - overlap))
    if window_type == 'hann':
      hann_window = np.hanning(window_size)
    else:
      hann_window = None
    for i in range(0, len(data) - window_size + 1, step):
      if hann_window is not None:
        yield data[i:i + window_size] * hann_window
      else:
        yield data[i:i + window_size]
from collections import Counter

# Energia normalizada = energia * período de amostragem
def energy(sig):
  return np.sum(sig ** 2)*0.01

def peak(sig):
  # Para função
  sig_fourier = np.fft.fft(sig) # sig é a janela a ser transformada
  sig_abs = np.abs(sig_fourier)

  peak = np.argmax(sig_abs)  # retorna indice

  frequencies = fftfreq(len(sig_abs)) # criando vetor das frequências
  peak_F = frequencies[peak]

  return peak_F

def cross_mean(sig):
    mean = np.mean(sig)
    cross = 0
    above = None

    for num in sig:
        if above is None:
            above = num > mean

        if num > mean:
            if not above: # Cruzou para cima se o anterior for para baixo
                cross += 1
                above = True
        elif num < mean:
            if above:  # Cruzou para baixo se o anterior for para cima
                cross += 1
                above = False

    return cross

def behavior(sig):
    counts = Counter(sig)
    total = len(sig)

    # Verificar se algum comportamento predominou com 75% ou mais
    for behavior, num in counts.items():
        if num/total >= 0.75:
            return behavior
    return '<undefined>'
window_size = 200
overlap = 0.5
id = []
ea=[]
eg=[]
pa=[]
pg=[]
cma=[]
cmg=[]
b=[]

for dog_id in dog_ids:
    dog = df[df['DogID'] == dog_id]
    a_win = list(windowing(dog['FilteredANorm'].values, 'hann', window_size=window_size, overlap=overlap))
    g_win = list(windowing(dog['FilteredGNorm'].values, 'hann', window_size=window_size, overlap=overlap))
    b1_win = list(windowing(dog['Behavior_1'].values, 'rect', window_size=window_size, overlap=overlap))
    b2_win = list(windowing(dog['Behavior_2'].values, 'rect', window_size=window_size, overlap=overlap))
    b3_win = list(windowing(dog['Behavior_3'].values, 'rect', window_size=window_size, overlap=overlap))

    for sig_w_a,sig_w_g,sig_w_b1,sig_w_b2,sig_w_b3 in zip(a_win,g_win,b1_win,b2_win,b3_win):
        id.append(dog_id)
        ea.append(energy(sig_w_a))
        eg.append(energy(sig_w_g))
        pa.append(peak(sig_w_a))
        pg.append(peak(sig_w_g))
        cma.append(cross_mean(sig_w_a))
        cmg.append(cross_mean(sig_w_g))

        sig_w_b = np.array([])
        for b1, b2, b3 in zip(sig_w_b1, sig_w_b2, sig_w_b3):
            unique = []
            for bn in (b1,b2,b3):
                if bn != '<undefined>':
                    unique.append(bn)
            if not unique:
                unique.append('<undefined>')
            sig_w_b = np.concatenate((sig_w_b,np.array(unique)), axis=0)
        b.append(behavior(np.array(sig_w_b)))
df_win = pd.DataFrame(columns = ['DogID', 'Energy_A', 'Energy_G', 'Peak_A', 'Peak_G', 'Cross_Mean_A', 'Cross_Mean_G', 'Behavior'])

df_win['DogID']=id
df_win['Energy_A']=ea
df_win['Energy_G']=eg
df_win['Peak_A']=pa
df_win['Peak_G']=pg
df_win['Cross_Mean_A']=cma
df_win['Cross_Mean_G']=cmg
df_win['Behavior']=b
df_win[df_win['Behavior']!='<undefined>'] # Tratar coluna de behavior para não armazenar dois ou mais comportamentos iguais por mediçãofig, axs = plt.subplots(2, 3, figsize=(12,8))
fig.suptitle('Histograma das Features')

axs[0, 0].hist(df_win['Energy_A'], bins=30)
axs[0, 0].set_title("Enegia do Acelerômetro")

axs[0, 1].hist(df_win['Peak_A'], bins=30)
axs[0, 1].set_title("Pico de frequência")

axs[0, 2].hist(df_win['Cross_Mean_A'], bins = 30)
axs[0, 2].set_title("Cruzamentos da média")


axs[1, 0].hist(df_win['Energy_G'], bins=30)
axs[1, 0].set_title("Enegia do Giroscópio")

axs[1, 1].hist(df_win['Peak_G'], bins=30)
axs[1, 1].set_title("Pico de frequência")

axs[1, 2].hist(df_win['Cross_Mean_G'], bins = 30)
axs[1, 2].set_title("Cruzamentos da média")
df_clf = df_win.loc[(df_win['Behavior'] == 'Galloping') | (df_win['Behavior'] == 'Standing') | (df_win['Behavior'] == 'Walking')]
df_clf
plt.subplot(2, 1, 2)
values, bins, bars = plt.hist(df_clf['Behavior'], orientation='vertical', bins=3)
plt.title('Histograma Behavior')
plt.bar_label(bars)
plt.ylim([0,7000])

plt.tight_layout()
plt.show()
import pandas as pd
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import f1_score
import matplotlib.pyplot as plt
import numpy as np


df_clf['Behavior'] = df_clf['Behavior'].replace({'Galope': 1, 'Em pé': 2, 'Andando': 3})


dog_ids = df_clf['DogID'].unique()


model_performance = []

for dog_id in dog_ids:
    train_data = df_clf.loc[df_clf['DogID'] != dog_id]
    X_train = np.array(train_data[['Energy_A', 'Energy_G', 'Peak_A', 'Peak_G', 'Cross_Mean_A', 'Cross_Mean_G']])
    y_train = np.array(train_data['Behavior'])

    test_data = df_clf.loc[df_clf['DogID'] == dog_id]
    X_test = np.array(test_data[['Energy_A', 'Energy_G', 'Peak_A', 'Peak_G', 'Cross_Mean_A', 'Cross_Mean_G']])
    y_test = np.array(test_data['Behavior'])

    clf = DecisionTreeClassifier(max_depth=5)
    clf.fit(X_train, y_train.ravel())


    y_pred = clf.predict(X_test)
    f1 = f1_score(y_test, y_pred, average='weighted')

    model_performance.append({
        'DogID': dog_id,
        'Model': clf,
        'F1_Score': f1
    })


df_model_performance = pd.DataFrame(model_performance)#new dataframe

#graficos
plt.figure(figsize=(10, 6))
plt.boxplot(df_model_performance['F1_Score'], vert=True, patch_artist=True)
plt.title('Distribuição dos Escores F1 do Classificador por DogID')
plt.ylabel('Escore F1')
plt.xticks([1], ['Decision Tree'])
plt.show()

plt.figure(figsize=(10, 6))
plt.hist(df_model_performance['F1_Score'], bins=10, edgecolor='black', alpha=0.7)
plt.title('Histograma dos Escores F1')
plt.xlabel('Escore F1')
plt.ylabel('Frequência')
plt.show()

plt.figure(figsize=(12, 6))
plt.bar(df_model_performance['DogID'], df_model_performance['F1_Score'], color='skyblue')
plt.title('Desempenho do Classificador (Escore F1) por DogID')
plt.xlabel('DogID')
plt.ylabel('Escore F1')
plt.xticks(rotation=45)
plt.show()

# Conclusão de desempenho
mean_f1 = df_model_performance['F1_Score'].mean()
std_f1 = df_model_performance['F1_Score'].std()
print(f"Escore F1 médio: {mean_f1:.4f}")
print(f"Desvio padrão do escore F1: {std_f1:.4f}")
# Representação da árvore do último modelo gerado
from sklearn.tree import export_graphviz
from six import StringIO
from IPython.display import Image
import pydotplus

dot_data = StringIO()
feature_cols = ['Energy_A', 'Energy_G', 'Peak_A', 'Peak_G', 'Cross_Mean_A', 'Cross_Mean_G']
export_graphviz(clf, out_file=dot_data, filled=True, rounded=True, special_characters=True,feature_names = feature_cols, max_depth=5, class_names=['1','2','3'])
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())
graph.write_png('behavior.png')
Image(graph.create_png())
